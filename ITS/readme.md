# QIIME2 analysis of ITS data
__This tutorial was simply extrapolated from the main tutorial__

1. [Rationale](#Rationale)
2. [Import ITS (Fungi) data](#step1--import-its-fungi-data)
3. [Quality controlling sequences and building Feature Table and Feature Data](#step2-quality-controlling-sequences-and-building-feature-table-and-feature-data)
4. [Summarizing Feature Table and Feature Data](#step-3-summarizing-feature-table-and-feature-data)
5. [Taxonomy assignment](#step-4-taxonomy-assignment)


## Rationale
To focus on the individual steps we decided to follow the 16S case study (ATACAMA) as the main workflow. In general, this pipeline can be used for any marker in metabarcoding studies but in some passages the biological nature (and therefore the problems) behind the choice of a certain marker must be considered.

We therefore decided, where necessary, to show the differences between the parameters to be used for the 16S or the ITS. We remind you, however, that each marker has a different evolutionary background given by the selective pressures, so this factor should be considered each time when using scripts.

![alt text](https://image.slidesharecdn.com/suryasahametagenomicstools-130507160129-phpapp02/95/tools-for-metagenomics-with-16sits-and-whole-genome-shotgun-sequences-3-638.jpg?cb=1369657346)

Since the differences (in terms of choice of parameters) only concern steps from 1 to 5 we have chosen to use data from a [mock community for ITS](http://mockrobiota.caporasolab.us/). This is to simplify the interpretation of the results as much as possible. By avoiding ecological problems we can focus on the differences given only by the nature of the marker itself.

This mock community is composed by 8 fungal species represented in uneven abundances.  This was generated by Dr. Lee Taylor at UNM, in 2016.

Listed in NCBI SRA as study SRR4070093. Known as Mock B in original publication.

Before starting to analyse fungal ITS data just a couple of consideration:
![its](ITS_region_schema.png)
*[https://benjjneb.github.io/dada2/ITS_workflow.html](https://benjjneb.github.io/dada2/ITS_workflow.html)*  
a. The amplified ITS region is longer than the read lengths, the forward and reverse reads overlap to capture the full amplified ITS region, but do not read into the opposite primer;  
b. The amplified ITS region is shorter than the read lengths, and the forward and reverse reads extend into the opposite primers which will appear in their reverse complement form towards the ends of those reads.  

Considering both scenarios pictured above typically occur within the same ITS dataset, a critical addition to ITS worfklows is the removal of primers on the forward and reverse reads, in a way that accounts for the possibility of read-through into the opposite primer.  
**PAY ATTENTION**: if the amplified region is longer than about 580 nt we are unable to merge reads.

## Step1:  Import ITS (Fungi) data

Create a new folder  
```
conda activate qiime2-2020.8
mkdir fungi_ITS_tutorial 
cd fungi_ITS_tutorial 
```
*In BASH, the `&&` allows you to perform two action on the same line*  

Download the sequences of the mock community in your new folder:  

```
wget -O "mock-25-sample-metadata.tsv" https://raw.githubusercontent.com/caporaso-lab/mockrobiota/master/data/mock-25/sample-metadata.tsv
wget https://s3-us-west-2.amazonaws.com/mockrobiota/latest/mock-25/mock-forward-read.fastq.gz
wget https://s3-us-west-2.amazonaws.com/mockrobiota/latest/mock-25/mock-reverse-read.fastq.gz
```

Create a  [fastq manifest file](https://docs.qiime2.org/2018.11/tutorials/importing/#fastq-manifest-formats)for importing these data into QIIME 2, fastqmanifest.csv:  
You have to create the **Manifest** file everytime you are not working with EMP or CASAVA data. 
```
echo "sample-id,absolute-filepath,direction" > fastqmanifest.csv
echo "Mock.1,$PWD/mock-forward-read.fastq.gz,forward" >> fastqmanifest.csv
echo "Mock.1,$PWD/mock-reverse-read.fastq.gz,reverse" >> fastqmanifest.csv
```
  
Now we can import the **FASTQ** data in a QIIME2 artifact and demultiplex it:   
```
qiime tools import \
 --type SampleData[PairedEndSequencesWithQuality] \
 --input-path fastqmanifest.csv \
 --output-path demux_fungi.qza \
 --input-format PairedEndFastqManifestPhred33
```

```
qiime demux summarize \
 --i-data demux_fungi.qza \
 --o-visualization demux_fungi.qzv
```

## Step2: Quality controlling sequences and building Feature Table and Feature Data
  
### Quality filter of ITS (optional for Friday groups)
One issue with ITS (and other marker genes with vast length variability) is *read-through*, which occurs when read lengths are longer than the amplicon itself!
Also in this case we want to trim primers from either end of the sequence to eliminate read-through issues.
The polymerase will read through the amplicon, the primer, the barcode, and on into the adapter sequence.  
This is non-biological DNA that will cause major issues downstream, e.g., with sequence classification. So we want to trim primers from either end of the sequence to eliminate read-through issues.  
*Note that we trim the forward primer and the reverse complement of the reverse primer from the forward reads (the forward primers have already been trimmed in the raw reads, but we will demonstrate forward + reverse trimming here since attempting to trim the forward read will not hurt). We trim the reverse primer and reverse complement of the forward primer from the reverse reads.*

|Primer|Sequence|
|:-:|:-:|
|Forward|AACTTTYRRCAAYGGATCWCT|  
|Reverse|AGCCTCCGCTTATTGATATGCTTAART|   

Note that we trim the forward primer (just in case it is still on the front of our sequences) and the reverse complement of the reverse primer from the forward reads. We trim the reverse primer and the complement of the forward primer from the reverse reads.
The primer trimming is performed by using the tool `cutadapt`[^1] 

```
qiime cutadapt trim-paired \
  --i-demultiplexed-sequences demux_fungi.qza \
  --p-adapter-f AYTTAAGCATATCAATAAGCGGAGGCT \
  --p-front-f AACTTTYRRCAAYGGATCWCT \
  --p-adapter-r AGWGATCCRTTGYYRAAAGTT \
  --p-front-r AGCCTCCGCTTATTGATATGCTTAART \
  --o-trimmed-sequences demux-trimmed.qza
```

```
qiime demux summarize \
 --i-data demux-trimmed.qza \
 --o-visualization demux-trimmed.qzv
```

***Why didn't we just cut the primers using length?***

Even though we have paired-end reads, the read quality in the mock-25 dataset is not good enough to support merging the expected amplicon length so we decide to use only forward reads.  
```
qiime dada2 denoise-single \
  --i-demultiplexed-seqs demux-trimmed.qza \
  --p-trim-left 13 \
  --p-trunc-len 160 \
  --p-n-threads 2 \
  --o-representative-sequences dada2-single-end-rep-seqs_ITS.qza \
  --o-table dada2-single-end-table_ITS.qza \
  --o-denoising-stats dada2-single-end-stats_ITS.qza
```

```
qiime metadata tabulate \
  --m-input-file dada2-single-end-stats_ITS.qza \
  --o-visualization dada2-single-end-stats_ITS.qzv
```

# Step 3: Summarizing Feature Table and Feature Data
Now You have artifacts containing the feature table and corresponding feature sequences. You can generate summaries of those as follows:

```
qiime feature-table summarize \
  --i-table dada2-single-end-table_ITS.qza \
  --o-visualization dada2-single-end-table_ITS.qzv \
  --m-sample-metadata-file mock-25-sample-metadata.tsv

qiime feature-table tabulate-seqs \
  --i-data dada2-single-end-rep-seqs_ITS.qza \
  --o-visualization dada2-single-end-rep-seqs_ITS.qzv
```

# Step 4 Taxonomy assignment 

## ITS taxonomy assignment 
The QIIME 2 plugin [feature-classifier](https://docs.qiime2.org/2019.1/plugins/available/feature-classifier/) supports taxonomic classification of features using a variety of methods, including Naive Bayes, vsearch, and BLAST+.

`q2-feature-classifier` contains three different classification methods. **classify-consensus-blast** and **classify-consensus-vsearch** are both **alignment-based methods** that find a consensus assignment across N top hits. These methods take reference database `FeatureData[Taxonomy]` and `FeatureData[Sequence]` files directly, and do not need to be pre-trained.

The first step in this process is to assign taxonomy to the sequences in our `FeatureData[Sequence]` QIIME 2 artifact. 

For ITS we will use the [**classify-consensus-vsearch**](https://docs.qiime2.org/2019.1/plugins/available/feature-classifier/classify-consensus-vsearch/). 
**If you want to use the the Naive Bayes classifier you need to train it but you don't need to trim UNITE sequences by using primers.**  
Please download the taxonomic data from **UNITE**:
```
mkdir unite_ref
```
```
cd unite_ref
```
```
wget -O "sh_qiime_release_10.10.2017.zip" \
  "https://unite.ut.ee/sh_files/sh_qiime_release_10.10.2017.zip"
```

```
unzip sh_qiime_release_10.10.2017.zip
```
Create artifacts for our reference fasta and taxonomy:
```
qiime tools import \
  --input-path sh_refs_qiime_ver7_99_10.10.2017.fasta \
  --output-path sh_refs_qiime_ver7_99_10.10.2017.qza \
  --type 'FeatureData[Sequence]'
  
qiime tools import \
 --type FeatureData[Taxonomy] \
 --input-path sh_taxonomy_qiime_ver7_99_10.10.2017.txt \
 --input-format HeaderlessTSVTaxonomyFormat \
 --output-path UNITE_taxonomy.qza
  
cd ..  
```

It's time to classify!!!

```
qiime feature-classifier classify-consensus-vsearch \
  --i-query dada2-single-end-rep-seqs_ITS.qza \
  --i-reference-reads unite_ref/sh_refs_qiime_ver7_99_10.10.2017.qza \
  --i-reference-taxonomy unite_ref/UNITE_taxonomy.qza \
  --p-threads 2 \
  --o-classification taxonomy_ITS.qza

qiime metadata tabulate \
  --m-input-file taxonomy_ITS.qza \
  --o-visualization taxonomy_ITS.qzv

```

Now create the barplot for vizualize your data

```
qiime taxa barplot \
  --i-table dada2-single-end-table_ITS.qza \
  --i-taxonomy taxonomy_ITS.qza \
  --m-metadata-file mock-25-sample-metadata.tsv \
  --o-visualization taxa-bar-plots_ITS.qzv
```



[^1]: [https://journal.embnet.org/index.php/embnetjournal/article/view/200/479](https://journal.embnet.org/index.php/embnetjournal/article/view/200/479)

[**Back to the program**](../README.md)